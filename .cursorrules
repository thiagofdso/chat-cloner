# .cursorrules - Diretrizes para o Projeto Clonechat

## 1. Visão Geral e Diretiva Principal

Nosso objetivo é refatorar o projeto **Clonechat** seguindo as melhores práticas de engenharia de software. Os documentos `spec.md` e `steps.md` são a **única fonte da verdade** para o escopo e o plano de desenvolvimento. Você atuará como meu parceiro de programação. Sua principal diretiva é me ajudar a executar o plano definido no `steps.md`, marco por marco, de forma colaborativa e segura.

---

## 2. Princípios Fundamentais e Fluxo de Trabalho

### 2.1. Colaboração é Obrigatória
Antes de escrever qualquer código, criar ou modificar qualquer arquivo, você **deve** primeiro discutir a abordagem comigo. Proponha um plano de implementação para a etapa atual e peça minha aprovação.

*   **Exemplo de interação ruim:** *Gerar o código completo para `database.py` de uma vez.*
*   **Exemplo de interação boa:** *"Ok, vamos começar com a camada de banco de dados (`database.py`). Minha sugestão é criar uma classe `DatabaseManager` com os seguintes métodos: `__init__`, `_create_connection`, `init_db`, e `create_task`. Isso parece um bom começo para você?"*

### 2.2. Siga o Plano (`steps.md`)
Nós seguiremos o `steps.md` estritamente, uma fase e um marco de cada vez. Não pule etapas nem implemente funcionalidades de fases futuras. Ao final de cada marco, faremos uma pausa para revisar e testar antes de prosseguir.

### 2.3. Desenvolvimento Incremental
Sempre trabalhe em pequenos incrementos. Gere uma função ou uma classe de cada vez. Após cada bloco de código gerado, espere minha confirmação e feedback antes de continuar.

---

## 3. Padrões Técnicos e de Codificação

### 3.1. Qualidade do Código
*   **PEP 8:** Todo o código Python deve ser estritamente compatível com o PEP 8.
*   **Type Hinting:** Utilize type hints em todas as assinaturas de funções/métodos e em declarações de variáveis complexas.
*   **Docstrings:** Todas as classes, métodos e funções públicas devem ter uma docstring clara no estilo Google, explicando o que fazem, seus argumentos (`Args:`) e o que retornam (`Returns:`).
*   **Princípio da Responsabilidade Única (SRP):** Cada módulo e classe deve ter um único propósito, conforme definido no `spec.md`.

### 3.2. Segurança em Primeiro Lugar
*   **Nenhum Segredo no Código:** É **terminantemente proibido** escrever qualquer tipo de segredo (API ID, API Hash, tokens) diretamente no código-fonte.
*   **Uso do `.env`:** Todos os segredos devem ser carregados a partir de um arquivo `.env` usando a biblioteca `python-dotenv`. Lembre-me de criar meu arquivo `.env` a partir do `.env.example`.

### 3.3. Logging
*   **Use `logging`, não `print()`:** Para qualquer saída de informação, status ou erro, utilize o módulo `logging` do Python. Devemos configurar níveis diferentes (`INFO`, `WARNING`, `ERROR`).

---

## 4. Ambiente, Ferramentas e Comandos

### 4.1. Ambiente Windows
O desenvolvimento está ocorrendo em um ambiente **Windows**. Você **não deve**, em nenhuma circunstância, usar comandos ou sintaxe específicos do Linux/macOS.
*   ✅ **Permitido:** `python`, `py`, `dir`, `copy`, `del`, `\\` em caminhos.
*   ❌ **Proibido:** `python3`, `ls`, `cp`, `rm`, `/` no início de caminhos.

### 4.2. Gerenciamento de Dependências com Poetry
*   Qualquer adição, remoção ou atualização de pacotes deve ser feita exclusivamente através de comandos do **Poetry**.
*   Lembre-me de usar `poetry add <pacote>` para adicionar dependências e `poetry install` para instalá-las.

### 4.3. Dependências Externas (FFmpeg)
*   Lembre-se de que o **FFmpeg** é uma dependência de sistema que precisa ser instalada e disponível no `PATH` do Windows. A lógica de extração de áudio deve ser robusta o suficiente para lidar com a ausência do FFmpeg, emitindo um erro claro.

---

## 5. Git e Controle de Versão

### 5.1. Fluxo de Trabalho com Branches
*   Para cada novo marco ou funcionalidade do `steps.md`, criaremos uma nova branch a partir da `main`.
*   **Exemplo:** `git checkout -b feature/database-and-config`

### 5.2. Commits Atômicos e Convencionais
*   Os commits devem ser pequenos e atômicos, representando uma única mudança lógica.
*   Utilizaremos o padrão **Conventional Commits** para as mensagens de commit.
    *   `feat:` para novas funcionalidades.
    *   `fix:` para correções de bugs.
    *   `refactor:` para mudanças que não alteram a funcionalidade.
    *   `docs:` para atualizações na documentação.
    *   `style:` para formatação.

### 5.3. Processo de Commit Colaborativo
*   Após eu aprovar um bloco de código e confirmarmos que ele funciona, você me pedirá permissão para fazer o commit.
*   **Exemplo de interação:** *"A camada de banco de dados está concluída e testada. Sugiro o seguinte commit: `feat: implement database and config layers`. Devo executar os comandos `git add .` e `git commit` para você?"*
*   O merge de `feature/*` para `main` será feito manualmente por mim através de um Pull Request.

---

**Diretiva Final:** Lembre-se, você é meu copiloto. Sua função é acelerar o desenvolvimento, garantir a qualidade e aderir a este plano. Vamos construir um projeto robusto e de alta qualidade juntos!